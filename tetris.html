<!DOCTYPE html>
<html>
   <head>
     <title>Tetris</title>
      <style> 
         body {
            background: #dddddd;
         }

         #canvas {
         	position: absolute;
         	left:0px;
         	top:0px;
         }
         
         #control {
         	 position: absolute;
         	 left: 400px;
         	 top: 0px;
         	 width: 160px;
         	 height: 440px;
         	 background: black;
         	}
         	
         	#preview {
	         	position: absolute;
	         	left: 400px;
	         	top:  440px;
	         	background: black;        		
         	}
        
      </style>
   </head>

  <body>

    <canvas id='canvas' width='400' height='600'>
      Canvas not supported
    </canvas>
    
    <canvas id='preview' width='160' height='160'>
      Canvas not supported	
    </canvas>
    
    <div id='control' align='center'>
    	  <input type='button' id='restartButton' value='Restart'/>
    	  <input type='button' id='pauseButton' value='Pause'/>
    </div>
    <!--
    <script src='tetris.js'></script>
    -->
<script>
var canvas = document.getElementById('canvas'),
    ctx = canvas.getContext('2d');
var previewCanvas = document.getElementById('preview'),
    previewCtx = previewCanvas.getContext('2d');

var pauseButton = document.getElementById('pauseButton'),
    restartButton = document.getElementById('restartButton');

    
var BLOCK_SIZE = 40,
    BOARD_WIDTH = 10,
    BOARD_HEIGHT = 15;

var shapes = [
[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:0,y:1}],
[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:2,y:1}],
[{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3}],
[{x:0,y:0},{x:0,y:1},{x:1,y:0},{x:1,y:1}],
[{x:1,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1}],
[{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:2,y:1}],
[{x:1,y:0},{x:2,y:0},{x:0,y:1},{x:1,y:1}]
];

var map;
var currentShape;
var previewShape;
var currentX;
var currentY;
var stopped;
var paused;
var timer;

restart();

window.onkeydown = function(e) {
	
	if (stopped) return;
	
	if (e.keyCode == 32) {
	  paused = !paused; 
	  return;
	}
	
  switch (e.keyCode) {
   case 37: e.preventDefault(); goLeft(); break;	
   case 39: e.preventDefault(); goRight(); break;
   case 38: e.preventDefault(); goRotate(); break;
   case 40: e.preventDefault(); goDown(); break;
  }	
};

pauseButton.onclick = function() {
  	if (stopped) return;
  	paused = !paused;
  	return;
  	
};

restartButton.onclick = function() {
  restart();
};

function drawBoard() {
	ctx.fillStyle='rgba(100, 100, 100, 1.0)'
	ctx.fillRect(0, 
							canvas.height - map.length * BLOCK_SIZE, 
							map[0].length * BLOCK_SIZE, 
							map.length * BLOCK_SIZE);
	ctx.fillStyle='rgba(100, 140, 230, 0.5)'
  drawMain(map, 
  						0, 
  						canvas.height - map.length * BLOCK_SIZE, 
  						currentShape, 
  						currentX, 
  						currentY, 
  						BLOCK_SIZE);
  drawPreview(previewShape, 
              computeCenter(4, shapeWidth(previewShape)), 
              computeCenter(4, shapeHeight(previewShape)), 
              BLOCK_SIZE);
}

function reset() {
	map = createMap(BOARD_WIDTH, BOARD_HEIGHT);
	currentShape = previewShape || genNextShape();
	previewShape = genNextShape();
	currentX = computeCenter(map[0].length, shapeWidth(currentShape));
	currentY = 0;
	stopped = true;
	paused = false;	
}

function tick() {
	console.log("Timer is active")
	var startY;
	
  if (paused) { 
	  return; 
  }
  
  if (goDown()) {
	  return;
  }
  
  addShape(map, currentShape, currentX, currentY, 1);
  removeFull(map);
	currentShape = previewShape; 
	currentX = computeCenter(map[0].length, shapeWidth(currentShape))
  previewShape = genNextShape();	
       	
  if (canPut(map, currentShape, currentX, 0)) {
    currentY = 0;
  } else {
   	currentY = -shapeHeight(currentShape);
  	var startY;
   	for (startY = 1; startY < shapeHeight(currentShape); startY++) {
   		if (canPutPart(map, currentShape, currentX, -startY, startY)) {
   		  currentY = -startY;
   		  break;
   		}
   	}     
    console.log("Cancel timer")
    clearInterval(timer);
    stopped = true
    paused = false
  }
 drawBoard();
}

function restart() {
	if (timer) { 
		clearInterval(timer); 
	}
	reset();
	drawBoard();
	timer = setInterval(tick, 500);
  stopped = false;
  paused = false;	
}

function tryPut(shape, relativeX, relativeY) {
  if(canPut(map, shape, 
            currentX+relativeX, currentY+relativeY)) {
    currentShape = shape;
  	currentX += relativeX;
    currentY += relativeY;
    drawBoard();
    return true;
  } else {
    return false;
  }	
}

function goDown() {
  return tryPut(currentShape, 0, 1);
}

function goLeft() {
  return tryPut(currentShape, -1, 0);	
}

function goRight() {
  return tryPut(currentShape, 1, 0);	
}

function goRotate() {
  var nextShape = turn(currentShape);

  return tryPut(nextShape, 0, 0) 
        || retryRotate(true, nextShape) 
        || retryRotate(false, nextShape);
}

function retryRotate(onX, nextShape) {

  var tryCount = onX? (shapeWidth(nextShape) - shapeWidth(currentShape)): 
                      (shapeHeight(nextShape) - shapeHeight(currentShape));
  var relativeX = 0;
  var telativeY = 0;
  if (onX) { 
    relativeX = - 1;
  } else {
    telativeY = - 1;
  }
  while(tryCount > 0) {
	  if (canPut(map, currentShape, currentX+relativeX, currentY+telativeY)) {
	  	if (tryPut(nextShape, relativeX, telativeY)) {
	      return true;
	    } else {
	      if (onX) {
	    	  relativeX = relativeX - 1;
	    	} else {
	    	  telativeY = telativeY - 1;
	    	}
	    }
	  } else {
			break;
	  }
	  tryCount--;
	}

	return false;
}

function genNextShape() {
  	var nextShape = shapes[parseInt(Math.random() * shapes.length)];
  	var turnCount = parseInt(Math.random() * 4);
  	for (i = 0; i < turnCount; i++) {
  	  nextShape = turn(nextShape)
  	}
  	return nextShape;	
}

function drawMain (map, startx, starty, shape, x, y, size) {
	var i,j;
	ctx.lineJoin = 'round';
	ctx.lineWidth = 10;
	for (i = 0; i < map.length; i++) {
		for (j = 0; j < map[0].length; j++) {
			if (map[i][j] > 0) {
			  drawBlock(ctx, j*size+startx, i*size+starty, size, size);
			}
		}	
	}
	if (shape == null) {
		return;
	}
	for (i = 0; i < shape.length; i++) {
		if ( y+shape[i].y >= 0) {
 	      drawBlock(ctx, 
 	      				  (x+shape[i].x)*size+startx, 
 	      				  (y+shape[i].y)*size+starty, 
 	      				  size, 
 	      				  size);
	  }
	}
}

function drawBlock(context, x, y, size, size) {
  context.fillRect(x, y, size, size);
}

function drawPreview(shape, x, y, size) {
	var i;
	previewCtx.clearRect(0, 0, 4*size, 4*size);
	previewCtx.fillStyle = 'rgba(100, 140, 230, 0.5)';
  for (i = 0; i < shape.length; i++) {
  	drawBlock(previewCtx, (x+shape[i].x)*size, (y+shape[i].y)*size, size, size);
  }
}

function turn(shape) {
  var ret = [];
  var min = 0;
  var i;
  for (i = 0; i < shape.length; i++) {
  	ret[i] = new Object();
  	ret[i].x = -shape[i].y;
  	if (ret[i].x < min) {
  		min = ret[i].x;
  	}
  	ret[i].y = shape[i].x;
  }
  for (i = 0; i < shape.length; i++) {
  	ret[i].x += -min;
  }
  return ret;
}

function shapeWidth(shape) {
  var len = 0;
  var i;
  for (i = 0; i < shape.length; i++) {
    if (shape[i].x > len) {
      len = shape[i].x;
    }
  }
  return len + 1;
}

function shapeHeight(shape) {
  var len = 0;
  var i;
  for (i = 0; i < shape.length; i++) {
    if (shape[i].y > len) {
      len = shape[i].y;
    }  
  }
  return len + 1;
}

function createMap(width, height) {
	var ret = [];
	var i, j;
	for (i = 0; i < height; i++) {
		ret[i] = [];
		for (j = 0; j < width; j++) {
			ret[i][j] = 0;
		} 
	}
	return ret;
}

function newMap(srcMap) {
	var i,j;
	ret = [];
  for (i = 0; i < srcMap.length; i++) {
    ret[i] = [];
    for (j = 0; j < srcMap[0].length; j++) {
      ret[i][j] = srcMap[i][j];
    }
  }
  return ret;
}

function rowFull(row) {
   var i;
   for (i = 0; i < row.length; i++) {
     if (row[i] == 0) {
       return false;
     }	
   }
   return true;
}

function copyRow(map, destRow, srcRow) {
   var i;
   for (i = 0; i < map[0].length; i++) {
      map[destRow][i]	= map[srcRow][i];
   }	
}

function fillRow(map, row, v) {
  var i;
  for (i = 0; i < map[0].length; i++) {
    map[row][i] = v;
  }
}

function removeRow(map, row) {
	var i;
	for (i = row; i > 0; i--) {
	  copyRow(map, i, i-1);
	}
	fillRow(map, 0, 0);
}

function findFull(map) {
  var ret = [];
  var count = 0;
  var i;
  for(i = 0; i < map.length; i++) {
    if (rowFull(map[i])) {
      ret[count] = i;
      count++;
    }	
  }	
  return ret;
}

function removeFull(map) {
	var i = map.length - 1;
	var fullRows = findFull(map);
	
	while (i >= 0) {
		if (rowFull(map[i])) {
			removeRow(map, i);
		} else {
			i--;
		}
	}
	return fullRows;
}

function canPut(map, shape, x, y) {
  return canPutPart(map, shape, x, y, 0);
}

function canPutPart(map, shape, x, y, startY) {
	var i, tx, ty;
  for (i = 0; i < 4; i++) {
  	if (shape[i].y < startY) {
  		continue;
  	}
  	tx = shape[i].x + x;
  	ty = shape[i].y + y;
    if (ty >= map.length || ty < 0 ) {
    	return false;
    }
    if (tx >= map[0].length || tx < 0) {
    	return false;
    }
    if (map[ty][tx] > 0) {
    	return false;
    }
  }	
  return true;
}

function addShape(map, shape, x, y, colorIndex) {
  var i;
  for (i = 0; i < shape.length; i++) {
  	map[shape[i].y + y][shape[i].x + x] = colorIndex;
  }	
}

function computeCenter(containerLength, shapeLength) {
  return Math.floor((containerLength - shapeLength) / 2);
}

</script>
  </body>
</html>
