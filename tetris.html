<!DOCTYPE html>
<html>
   <head>
     <title>Tetris</title>
      <style> 
         body {
           background: #dddddd;
         }

         #mainPane {
           position: absolute;
           left: 50%;
           margin-left: -285px;
         }

         #canvas {
           float: left;
           background: rgb(23,4,8);
         }

         #controlPane {
           float: right; 
           margin-left: 3px;
         }
         
         #control {
           width: 160px;
           height: 350px;
           background: black;
         }
          
         #previewPane {
           height: 160px;  
         }
          
         #preview {
            padding: 10px; 
            background: rgb(23,4,8);            
         }
          
         #scorePane {
           height: 70px;
           font-size: 32pt;
           color: red;
           padding-top: 20px; 
           background: black;
         }
          
         #control input {
           width: 120px;
           height: 50px;
           margin: 10px;
           color: rgb(45, 18, 25);
           font-size: 14pt;
           font-family: "Lucida Grande", Verdana, Lucida, Arial, Helvetica, sans-serif;;
         }      
      </style>
   </head>

  <body>
    <div id='mainPane'> 
      <canvas id='canvas' width='400' height='600'>
        Canvas not supported
      </canvas>    
      <div id='controlPane'>        
        <div id='control' align='center'>
            <input type='button' id='restartButton' value='Restart'/>
            <input type='button' id='pauseButton' value='Pause'/>
        </div>        
        <div id='previewPane'>
          <canvas id='preview' width='140' height='140'>
            Canvas not supported  
          </canvas>
        </div>      
        <div id='scorePane' align='center'>
          <p>0</p>
        </div>      
      </div>    
    </div>

<script>
"use strict"; 
    
var BLOCK_SIZE = 40;
var BOARD_WIDTH = 10;
var BOARD_HEIGHT = 15;
var PREVIEW_BLOCK_SIZE = 35;

var COLORS = [
    'rgb(226, 50, 88)',
    'rgb(203, 192, 130)',
    'rgb(103, 145, 123)',
    'rgb(183, 175, 2)'
];

var SHAPES = [
[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:0,y:1}],
[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:2,y:1}],
[{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3}],
[{x:0,y:0},{x:0,y:1},{x:1,y:0},{x:1,y:1}],
[{x:1,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1}],
[{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:2,y:1}],
[{x:1,y:0},{x:2,y:0},{x:0,y:1},{x:1,y:1}]
];

var UP = 0,
    DOWN = 1,
    LEFT = 2,
    RIGHT = 3;

var INTERVAL = 500;

var canvas = document.getElementById('canvas');
var previewCanvas = document.getElementById('preview');
var controlPane = document.getElementById('control');
var scorePane = document.getElementById('scorePane');
var ctx = canvas.getContext('2d');
var previewCtx = previewCanvas.getContext('2d');
var pauseButton = document.getElementById('pauseButton');
var restartButton = document.getElementById('restartButton');

var map;
var currentShape;
var previewShape;
var currentX;
var currentY;
var currentColor;
var previewColor;
var stopped;
var paused;
var timer;
var blinking
var blinkOn
var blinkColor;
var score;
var touchStartX
var touchStartY

restart();

window.onkeydown = function(e) {  
  if (stopped || paused) return;
  
  switch (e.keyCode) {
    case 37: e.preventDefault(); goLeft(); break; 
    case 39: e.preventDefault(); goRight(); break;
    case 38: e.preventDefault(); goRotate(); break;
    case 40: e.preventDefault(); goDown(); break;
  } 
};

document.addEventListener('touchstart', function onTouchStart(event) {
	if (stopped || paused) return;
	event.preventDefault();
	
  touchStartX = event.touches[0].pageX;
  touchStartY = event.touches[0].pageY;  
}, false);

document.addEventListener('touchend', function onTouchEnd(event) {
	if (stopped || paused) return;
	event.preventDefault();
	
  touchEndX = event.changedTouches[0].pageX;
  touchEndY = event.changedTouches[0].pageY;

  switch (computeGesture(touchStartX, touchStartY, touchEndX, touchEndY)) {
  	  case LEFT: goLeft(); break;
      case RIGHT: goRight(); break;
      case UP: goRotate(); break;
      case DOWN: goDown(); break;
  }
}, false);

pauseButton.onclick = function() {
  if (stopped) { 
    return;
  } 
  paused = !paused;
  updateButtonText();
};

restartButton.onclick = function() {
  restart();
};

//=============== FUNCTIONS ===============

function reset() {
  map = createMap(BOARD_WIDTH, BOARD_HEIGHT);
  if (previewShape != null) {
    currentShape = previewShape;
    currentColor = previewColor;  
  } else {
    currentShape = genNextShape();
    currentColor = parseInt(Math.random() * COLORS.length) + 1;
  }
  previewShape = genNextShape();
  previewColor = parseInt(Math.random() * COLORS.length) + 1;
  currentX = computeCenter(map[0].length, shapeWidth(currentShape));
  currentY = 0;
  stopped = true;
  paused = false; 
  blinking = false;
  blinkOn = false;
  score = 0;
}

function restart() {
  if (timer) { 
    clearInterval(timer); 
  }
  reset();
  drawBoard();
  timer = setInterval(tick, INTERVAL);
  stopped = false;
  paused = false; 
  updateButtonText();
}

function drawMain (map, shape, x, y, size) {
  var i,j;
  var blinkRow = false;
  for (i = 0; i < map.length; i++) {
    blinkRow = (rowFull(map[i]) > 0);
    for (j = 0; j < map[0].length; j++) {
      if (map[i][j] > 0) {
        if (blinkRow && blinkOn) {
          ctx.clearRect(ctx, 
                        j * size, 
                        i * size, 
                        size, 
                        size);
        } else {
          ctx.fillStyle = COLORS[map[i][j]-1];
          drawBlock(ctx, 
                    j * size, 
                    i * size, 
                    size, 
                    size);
        }
      }
    } 
  }
  if (blinking) {
    return;
  }
  for (i = 0; i < shape.length; i++) {
    if ((y + shape[i].y) >= 0) {
        ctx.fillStyle = COLORS[currentColor - 1];
        drawBlock(ctx, 
                  (x + shape[i].x) * size, 
                  (y + shape[i].y) * size, 
                  size, 
                  size);
    }
  }
}

function drawBlock(context, x, y, size) {
  context.fillRect(x + 1, y + 1, size - 2, size - 2);
}

function drawPreview(shape, x, y, size) {
  var i;
  previewCtx.clearRect(0, 0, 4 * size, 4 * size);
  previewCtx.fillStyle = COLORS[previewColor - 1];
  for (i = 0; i < shape.length; i++) {
    drawBlock(previewCtx, 
             (x + shape[i].x) * size, 
             (y + shape[i].y) * size, 
             size, 
             size);
  }
}

function drawBoard() {
  ctx.clearRect(0, 
              canvas.height - map.length * BLOCK_SIZE, 
              map[0].length * BLOCK_SIZE, 
              map.length * BLOCK_SIZE);
  drawMain(map, 
           currentShape, 
           currentX, 
           currentY, 
           BLOCK_SIZE);
  drawPreview(previewShape, 
              computeCenter(4, shapeWidth(previewShape)), 
              computeCenter(4, shapeHeight(previewShape)), 
              PREVIEW_BLOCK_SIZE);
  scorePane.innerHTML = score;
}

function updateButtonText() {
  if (paused) {
    pauseButton.value = "Resume"; 
  } else {
    pauseButton.value = "Pause";
  }
}

function computeGesture(startX, startY, endX, endY) {

    var deltaX = endX - startX,
        deltaY = endY - startY;

    if (deltaX < 0) {
        if (Math.abs(deltaY) < -deltaX) {
            return LEFT;  
        } else if (deltaY > 0) {
            return DOWN;
        } else {
            return UP;
        }
    } else {
        if (Math.abs(deltaY) < deltaX) {
            return RIGHT;
        } else if (deltaY > 0) {
            return DOWN;
        } else {
            return UP;
        }
    }
}

function tick() {
  console.log("Timer is active")
  var startY;
  var delay = 0;
  var fullRow;
  var i;
  var timeoutValue;
  
  if (paused) { 
    return; 
  }
  
  if (goDown()) {
    return;
  }
  
  addShape(map, currentShape, currentX, currentY, currentColor);
  fullRow = findFull(map);
  if (fullRow.length > 0) {
    blinking = true;
    blinkOn = true;
    drawBoard();    
    for (i = 0; i < 3; i++) {
      timeoutValue = (i + 1) * 100;
      setTimeout(function(){
              blinkOn = !blinkOn;
              drawBoard();
      }, timeoutValue);
    }   
    delay = 310;
  }
  setTimeout(function() {
    blinking = false;
    score += fullRow.length;
    removeFull(map);
    currentShape = previewShape; 
    currentColor = previewColor;
    currentX = computeCenter(map[0].length, shapeWidth(currentShape))
    previewShape = genNextShape();  
    previewColor = parseInt(Math.random() * COLORS.length) + 1;
          
    if (canPut(map, currentShape, currentX, 0)) {
      currentY = 0;
      drawBoard();
    } else {
      currentY = -shapeHeight(currentShape);
      var startY;
      for (startY = 1; startY < shapeHeight(currentShape); startY++) {
        if (canPutPart(map, currentShape, currentX, -startY, startY)) {
          currentY = -startY;
          break;
        }
      }     
      stopped = true;
      paused = false;
      drawBoard();
      ctx.font = '32pt Helvetica';
      ctx.fillStyle = 'red';
      ctx.fillText('GAME OVER', canvas.width / 2 - 130, 200);
      clearInterval(timer);
    }
  }, delay);
}

function tryPut(shape, relativeX, relativeY) {
  if(canPut(map, shape, 
            currentX + relativeX, currentY + relativeY)) {
    currentShape = shape;
    currentX += relativeX;
    currentY += relativeY;
    drawBoard();
    return true;
  } else {
    return false;
  } 
}

function goDown() {
  return tryPut(currentShape, 0, 1);
}

function goLeft() {
  return tryPut(currentShape, -1, 0); 
}

function goRight() {
  return tryPut(currentShape, 1, 0);  
}

function goRotate() {
  var nextShape = turn(currentShape);

  return tryPut(nextShape, 0, 0) 
        || retryRotate(true, nextShape) 
        || retryRotate(false, nextShape);
}

function retryRotate(onX, nextShape) {

  var tryCount = onX? (shapeWidth(nextShape) - shapeWidth(currentShape)): 
                      (shapeHeight(nextShape) - shapeHeight(currentShape));
  var relativeX = 0;
  var telativeY = 0;
  if (onX) { 
    relativeX = -1;
  } else {
    telativeY = -1;
  }
  while(tryCount > 0) {
    if (canPut(map, currentShape, currentX + relativeX, currentY + telativeY)) {
      if (tryPut(nextShape, relativeX, telativeY)) {
        return true;
      } else {
        if (onX) {
          relativeX = relativeX - 1;
        } else {
          telativeY = telativeY - 1;
        }
      }
    } else {
      break;
    }
    tryCount--;
  }

  return false;
}

function genNextShape() {
  var i;
  var nextShape = SHAPES[parseInt(Math.random() * SHAPES.length)];
  var turnCount = parseInt(Math.random() * 4);
  for (i = 0; i < turnCount; i++) {
    nextShape = turn(nextShape)
  }
  return nextShape; 
}

function turn(shape) {
  var ret = [];
  var min = 0;
  var i;
  for (i = 0; i < shape.length; i++) {
    ret[i] = {};
    ret[i].x = -shape[i].y;
    if (ret[i].x < min) {
      min = ret[i].x;
    }
    ret[i].y = shape[i].x;
  }
  for (i = 0; i < shape.length; i++) {
    ret[i].x += -min;
  }
  return ret;
}

function shapeWidth(shape) {
  var len = 0;
  var i;
  for (i = 0; i < shape.length; i++) {
    if (shape[i].x > len) {
      len = shape[i].x;
    }
  }
  return len + 1;
}

function shapeHeight(shape) {
  var len = 0;
  var i;
  for (i = 0; i < shape.length; i++) {
    if (shape[i].y > len) {
      len = shape[i].y;
    }  
  }
  return len + 1;
}

function createMap(width, height) {
  var ret = [];
  var i, j;
  for (i = 0; i < height; i++) {
    ret[i] = [];
    for (j = 0; j < width; j++) {
      ret[i][j] = 0;
    } 
  }
  return ret;
}

function rowFull(row) {
   var i;
   for (i = 0; i < row.length; i++) {
     if (row[i] == 0) {
       return false;
     }  
   }
   return true;
}

function copyRow(map, destRow, srcRow) {
   var i;
   for (i = 0; i < map[0].length; i++) {
      map[destRow][i] = map[srcRow][i];
   }  
}

function fillRow(map, row, v) {
  var i;
  for (i = 0; i < map[0].length; i++) {
    map[row][i] = v;
  }
}

function findFull(map) {
  var ret = [];
  var count = 0;
  var i;
  for(i = 0; i < map.length; i++) {
    if (rowFull(map[i])) {
      ret[count] = i;
      count++;
    } 
  } 
  return ret;
}

function removeFull(map) {
  var i = map.length - 1;
  var j;
  while (i >= 0 && !rowFull(map[i])) {
    i--;  
  }
  j = i - 1;
  while (j >= 0) {
    while (j >= 0 && rowFull(map[j])) {
      j--;
    } 
    if (j >= 0) {
      copyRow(map, i, j);
      i--;
      j--;  
    }
  } 
  while (i >= 0) {
    fillRow(map, i, 0);
    i--;
  }
}

function canPut(map, shape, x, y) {
  return canPutPart(map, shape, x, y, 0);
}

function canPutPart(map, shape, x, y, startY) {
  var i, tx, ty;
  for (i = 0; i < 4; i++) {
    if (shape[i].y < startY) {
      continue;
    }
    tx = shape[i].x + x;
    ty = shape[i].y + y;
    if (ty >= map.length || ty < 0 ) {
      return false;
    }
    if (tx >= map[0].length || tx < 0) {
      return false;
    }
    if (map[ty][tx] > 0) {
      return false;
    }
  } 
  return true;
}

function addShape(map, shape, x, y, colorIndex) {
  var i;
  for (i = 0; i < shape.length; i++) {
    map[shape[i].y + y][shape[i].x + x] = colorIndex;
  } 
}

function computeCenter(containerLength, shapeLength) {
  return Math.floor((containerLength - shapeLength) / 2);
}

</script>
  </body>
</html>
